rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // =====================================
    // ðŸ”’ REGRAS PARA COLEÃ‡ÃƒO DE USUÃRIOS
    // =====================================
    
    match /users/{userId} {
      // UsuÃ¡rios podem apenas ler seus prÃ³prios documentos
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Escrita apenas com validaÃ§Ã£o (CORRIGIDO: removida regra duplicada)
      allow create, update: if request.auth != null 
                           && request.auth.uid == userId
                           && validateUserData(request.resource.data);
      
      // NOVA: Permitir atualizaÃ§Ãµes de verificaÃ§Ã£o de email sem autenticaÃ§Ã£o
      // Especificamente para sincronizaÃ§Ã£o apÃ³s verificaÃ§Ã£o de email
      allow update: if isEmailVerificationUpdate(request.resource.data, resource.data);
    }
    
    // =====================================
    // ðŸ”’ REGRAS PARA COLEÃ‡ÃƒO DE EMAIL
    // =====================================
    
    match /mail/{emailId} {
      // Apenas o sistema pode escrever emails (via Admin SDK)
      // UsuÃ¡rios nÃ£o podem ler ou escrever emails diretamente
      allow read, write: if false;
    }
    
    // =====================================
    // ðŸ”’ REGRAS PARA OUTRAS COLEÃ‡Ã•ES
    // =====================================
    
    // Qualquer outra coleÃ§Ã£o nÃ£o especificada Ã© bloqueada por padrÃ£o
    match /{document=**} {
      allow read, write: if false;
    }
    
    // =====================================
    // ðŸ”§ FUNÃ‡Ã•ES DE VALIDAÃ‡ÃƒO
    // =====================================
    
    function validateUserData(data) {
      // Validar campos obrigatÃ³rios
      return data.keys().hasAll(['Nome', 'email', 'created_at'])
      
      // Validar tipos de dados
      && data.Nome is string
      && data.email is string
      && data.email.matches('.*@.*\\..*') // Formato bÃ¡sico de email
      
      // Validar tamanhos
      && data.Nome.size() > 0 && data.Nome.size() <= 100
      && data.email.size() > 0 && data.email.size() <= 255
      
      // Validar campos opcionais se presentes
      && (data.phone == null || (data.phone is string && data.phone.size() <= 20))
      && (data.country == null || (data.country is string && data.country.size() <= 50))
      
      // Validar que UID corresponde ao documento (CORRIGIDO: suporte para criaÃ§Ã£o)
      && data.id == userId
      
      // Validar que o email no documento corresponde ao email do usuÃ¡rio autenticado
      && data.email == request.auth.token.email;
    }
    
    // FunÃ§Ã£o para validar atualizaÃ§Ãµes de verificaÃ§Ã£o de email
    function isEmailVerificationUpdate(newData, existingData) {
      // Verificar se apenas campos relacionados Ã  verificaÃ§Ã£o estÃ£o sendo alterados
      let changedFields = newData.diff(existingData).changedKeys();
      
      // Campos permitidos para atualizaÃ§Ã£o sem autenticaÃ§Ã£o
      let allowedFields = ['email_verified', 'account_status', 'updated_at', 
                          'sync_method', 'last_verification_sync', 'email_verified_at'].toSet();
      
      // Verificar se todos os campos alterados estÃ£o na lista permitida
      return changedFields.hasAny(allowedFields) 
             && changedFields.hasOnly(allowedFields)
             
             // Validar valores especÃ­ficos
             && (newData.email_verified == true || newData.email_verified == false)
             && (newData.account_status == 'active' || newData.account_status == 'pending_verification')
             
             // Garantir que campos crÃ­ticos nÃ£o foram alterados
             && newData.email == existingData.email
             && newData.Nome == existingData.Nome
             && newData.id == existingData.id;
    }
  }
} 